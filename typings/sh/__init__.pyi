"""
This type stub file was generated by pyright.
"""

import platform
import sys
import traceback
import os
import re
import time
import getpass
import inspect
import tempfile
from typing import Optional
import warnings
import stat
import glob as glob_module
import ast
import pwd
import errno
import pty
import termios
import signal
import gc
import select
import threading
import tty
import fcntl
import struct
import resource
import logging
import weakref
from types import GeneratorType, ModuleType
from functools import partial
from collections import deque
from contextlib import contextmanager
from io import BytesIO as cStringIO, StringIO, UnsupportedOperation, open as fdopen
from locale import getpreferredencoding
from queue import Empty, Queue

# from StringIO import StringIO
# from cStringIO import OutputType as cStringIO
# from Queue import Empty, Queue

"""
http://amoffat.github.io/sh/
"""
__version__ = "1.13.1"
__project_url__ = "https://github.com/amoffat/sh"
if "windows" in platform.system().lower(): ...
IS_PY3 = sys.version_info[0] == 3
MINOR_VER = sys.version_info[1]
IS_PY26 = sys.version_info[0] == 2 and MINOR_VER == 6
DEFAULT_ENCODING = getpreferredencoding() or "UTF-8"
RUNNING_TESTS = bool(int(os.environ.get("SH_TESTS_RUNNING", "0")))
FORCE_USE_SELECT = bool(int(os.environ.get("SH_TESTS_USE_SELECT", "0")))
if IS_PY3:
    ioStringIO = StringIO
    iocStringIO = cStringIO
else: ...
IS_MACOS = platform.system() in ("AIX", "Darwin")
THIS_DIR = os.path.dirname(os.path.realpath(__file__))
SH_LOGGER_NAME = __name__
PUSHD_LOCK = threading.RLock()
if hasattr(inspect, "getfullargspec"):
    def get_num_args(fn): ...

else:
    def get_num_args(fn): ...

if IS_PY3:
    raw_input = input
    unicode = str
    basestring = str
    long = int
_unicode_methods = set(dir(unicode()))
HAS_POLL = hasattr(select, "poll")
POLLER_EVENT_READ = 1
POLLER_EVENT_WRITE = 2
POLLER_EVENT_HUP = 4
POLLER_EVENT_ERROR = 8
if HAS_POLL and not FORCE_USE_SELECT:
    class Poller(object):
        def __init__(self) -> None: ...
        def __nonzero__(self): ...
        def __len__(self): ...
        def register_read(self, f): ...
        def register_write(self, f): ...
        def register_error(self, f): ...
        def unregister(self, f): ...
        def poll(self, timeout): ...

else:
    class Poller(object):
        def __init__(self) -> None: ...
        def __nonzero__(self): ...
        def __len__(self): ...
        def register_read(self, f): ...
        def register_write(self, f): ...
        def register_error(self, f): ...
        def unregister(self, f): ...
        def poll(self, timeout): ...

def encode_to_py3bytes_or_py2str(s):
    """takes anything and attempts to return a py2 string or py3 bytes.  this
    is typically used when creating command + arguments to be executed via
    os.exec*"""
    ...

class ForkException(Exception):
    def __init__(self, orig_exc) -> None: ...

class ErrorReturnCodeMeta(type):
    """a metaclass which provides the ability for an ErrorReturnCode (or
    derived) instance, imported from one sh module, to be considered the
    subclass of ErrorReturnCode from another module.  this is mostly necessary
    in the tests, where we do assertRaises, but the ErrorReturnCode that the
    program we're testing throws may not be the same class that we pass to
    assertRaises
    """

    def __subclasscheck__(self, o): ...

class ErrorReturnCode(Exception):
    __metaclass__ = ...
    truncate_cap = ...
    # full_cmd: Unknown
    stdout: bytes
    stderr: bytes
    truncate: bool
    exit_code: int
    def __reduce__(self): ...
    def __init__(self, full_cmd, stdout, stderr, truncate=...) -> None: ...

class SignalException(ErrorReturnCode): ...

class TimeoutException(Exception):
    """the exception thrown when a command is killed because a specified
    timeout (via _timeout or .wait(timeout)) was hit"""

    def __init__(self, exit_code, full_cmd) -> None: ...

SIGNALS_THAT_SHOULD_THROW_EXCEPTION = set(
    (
        signal.SIGABRT,
        signal.SIGBUS,
        signal.SIGFPE,
        signal.SIGILL,
        signal.SIGINT,
        signal.SIGKILL,
        signal.SIGPIPE,
        signal.SIGQUIT,
        signal.SIGSEGV,
        signal.SIGTERM,
        signal.SIGSYS,
    )
)

class CommandNotFound(AttributeError): ...

rc_exc_regex = re.compile(r"(ErrorReturnCode|SignalException)_((\d+)|SIG[a-zA-Z]+)")
rc_exc_cache = {}
SIGNAL_MAPPING = {}

def get_exc_from_name(name):
    """takes an exception name, like:

        ErrorReturnCode_1
        SignalException_9
        SignalException_SIGHUP

    and returns the corresponding exception.  this is primarily used for
    importing exceptions from sh into user code, for instance, to capture those
    exceptions"""
    ...

def get_rc_exc(rc):
    """takes a exit code or negative signal number and produces an exception
    that corresponds to that return code.  positive return codes yield
    ErrorReturnCode exception, negative return codes yield SignalException

    we also cache the generated exception so that only one signal of that type
    exists, preserving identity"""
    ...

_old_glob = glob_module.glob

class GlobResults(list):
    def __init__(self, path, results) -> None: ...

def glob(path, *args, **kwargs): ...
def canonicalize(path): ...
def which(program, paths=...):
    """takes a program name or full path, plus an optional collection of search
    paths, and returns the full path of the requested executable.  if paths is
    specified, it is the entire list of search paths, and the PATH env is not
    used at all.  otherwise, PATH env is used to look for the program"""
    ...

def resolve_command_path(program): ...
def resolve_command(name, baked_args=...): ...

class Logger(object):
    """provides a memory-inexpensive logger.  a gotcha about python's builtin
    logger is that logger objects are never garbage collected.  if you create a
    thousand loggers with unique names, they'll sit there in memory until your
    script is done.  with sh, it's easy to create loggers with unique names if
    we want our loggers to include our command arguments.  for example, these
    are all unique loggers:

            ls -l
            ls -l /tmp
            ls /tmp

    so instead of creating unique loggers, and without sacrificing logging
    output, we use this class, which maintains as part of its state, the logging
    "context", which will be the very unique name.  this allows us to get a
    logger with a very general name, eg: "command", and have a unique name
    appended to it via the context, eg: "ls -l /tmp" """

    def __init__(self, name, context=...) -> None: ...
    def set_context(self, context): ...
    def get_child(self, name, context): ...
    def info(self, msg, *args): ...
    def debug(self, msg, *args): ...
    def error(self, msg, *args): ...
    def exception(self, msg, *args): ...

def default_logger_str(cmd, call_args, pid=...): ...

class RunningCommand(object):
    """this represents an executing Command object.  it is returned as the
    result of __call__() being executed on a Command instance.  this creates a
    reference to a OProc instance, which is a low-level wrapper around the
    process that was exec'd

    this is the class that gets manipulated the most by user code, and so it
    implements various convenience methods and logical mechanisms for the
    underlying process.  for example, if a user tries to access a
    backgrounded-process's stdout/err, the RunningCommand object is smart enough
    to know to wait() on the process to finish first.  and when the process
    finishes, RunningCommand is smart enough to translate exit codes to
    exceptions."""

    _OProc_attr_whitelist = ...
    def __init__(self, cmd, call_args, stdin, stdout, stderr) -> None:
        """
        cmd is a list, where each element is encoded as bytes (PY3) or str (PY2)
        """
        ...
    def wait(self, timeout=...):
        """waits for the running command to finish.  this is called on all
        running commands, eventually, except for ones that run in the background

        if timeout is a number, it is the number of seconds to wait for the process to resolve. otherwise block on wait.

        this function can raise a TimeoutException, either because of a `_timeout` on the command itself as it was
        launched, or because of a timeout passed into this method.
        """
        ...
    def is_alive(self):
        """ returns whether or not we're still alive. this call has side-effects on OProc """
        ...
    def handle_command_exit_code(self, code):
        """here we determine if we had an exception, or an error code that we
        weren't expecting to see.  if we did, we create and raise an exception
        """
        ...
    @property
    def stdout(self) -> bytes: ...
    @property
    def stderr(self) -> bytes: ...
    @property
    def exit_code(self) -> int: ...
    def __len__(self): ...
    def __enter__(self):
        """we don't actually do anything here because anything that should have
        been done would have been done in the Command.__call__ call.
        essentially all that has to happen is the comand be pushed on the
        prepend stack."""
        ...
    def __iter__(self): ...
    def next(self):
        """ allow us to iterate over the output of our command """
        ...
    __next__ = ...
    def __exit__(self, typ, value, traceback): ...
    def __str__(self) -> str:
        """in python3, should return unicode.  in python2, should return a
        string of bytes"""
        ...
    def __unicode__(self):
        """a magic method defined for python2.  calling unicode() on a
        RunningCommand object will call this"""
        ...
    def __eq__(self, other) -> bool: ...
    __hash__ = ...
    def __contains__(self, item): ...
    def __getattr__(self, p): ...
    def __repr__(self):
        """in python3, should return unicode.  in python2, should return a
        string of bytes"""
        ...
    def __long__(self): ...
    def __float__(self): ...
    def __int__(self) -> int: ...

def output_redirect_is_filename(out): ...
def get_prepend_stack(): ...
def special_kwarg_validator(passed_kwargs, merged_kwargs, invalid_list): ...
def get_fileno(ob): ...
def ob_is_fd_based(ob): ...
def ob_is_tty(ob):
    """ checks if an object (like a file-like object) is a tty.  """
    ...

def ob_is_pipe(ob): ...
def tty_in_validator(passed_kwargs, merged_kwargs): ...
def fg_validator(passed_kwargs, merged_kwargs):
    """ fg is not valid with basically every other option """
    ...

def bufsize_validator(passed_kwargs, merged_kwargs):
    """a validator to prevent a user from saying that they want custom
    buffering when they're using an in/out object that will be os.dup'd to the
    process, and has its own buffering.  an example is a pipe or a tty.  it
    doesn't make sense to tell them to have a custom buffering, since the os
    controls this."""
    ...

def env_validator(passed_kwargs, merged_kwargs):
    """a validator to check that env is a dictionary and that all environment variable
    keys and values are strings. Otherwise, we would exit with a confusing exit code 255."""
    ...

class Command(object):
    """represents an un-run system program, like "ls" or "cd".  because it
    represents the program itself (and not a running instance of it), it should
    hold very little state.  in fact, the only state it does hold is baked
    arguments.

    when a Command object is called, the result that is returned is a
    RunningCommand object, which represents the Command put into an execution
    state."""

    thread_local = ...
    _call_args = ...
    _kwarg_validators = ...
    def __init__(self, path, search_paths=...) -> None: ...
    def __getattribute__(self, name: str) -> Command: ...
    def bake(self, *args, **kwargs): ...
    def __str__(self) -> str:
        """in python3, should return unicode.  in python2, should return a
        string of bytes"""
        ...
    def __eq__(self, other) -> bool: ...
    __hash__ = ...
    def __repr__(self):
        """in python3, should return unicode.  in python2, should return a
        string of bytes"""
        ...
    def __unicode__(self):
        """a magic method defined for python2.  calling unicode() on a
        self will call this"""
        ...
    def __enter__(self): ...
    def __exit__(self, typ, value, traceback): ...
    def __call__(self, *args, **kwargs) -> Optional[RunningCommand]: ...

def compile_args(args, kwargs, sep, prefix):
    """takes args and kwargs, as they were passed into the command instance
    being executed with __call__, and compose them into a flat list that
    will eventually be fed into exec.  example:

    with this call:

        sh.ls("-l", "/tmp", color="never")

    this function receives

        args = ['-l', '/tmp']
        kwargs = {'color': 'never'}

    and produces

        ['-l', '/tmp', '--color=never']

    """
    ...

def aggregate_keywords(keywords, sep, prefix, raw=...):
    """take our keyword arguments, and a separator, and compose the list of
    flat long (and short) arguments.  example

        {'color': 'never', 't': True, 'something': True} with sep '='

    becomes

        ['--color=never', '-t', '--something']

    the `raw` argument indicates whether or not we should leave the argument
    name alone, or whether we should replace "_" with "-".  if we pass in a
    dictionary, like this:

        sh.command({"some_option": 12})

    then `raw` gets set to True, because we want to leave the key as-is, to
    produce:

        ['--some_option=12']

    but if we just use a command's kwargs, `raw` is False, which means this:

        sh.command(some_option=12)

    becomes:

        ['--some-option=12']

    eessentially, using kwargs is a convenience, but it lacks the ability to
    put a '-' in the name, so we do the replacement of '_' to '-' for you.
    but when you really don't want that to happen, you should use a
    dictionary instead with the exact names you want
    """
    ...

def setwinsize(fd, rows_cols):
    """set the terminal size of a tty file descriptor.  borrowed logic
    from pexpect.py"""
    ...

def construct_streamreader_callback(process, handler):
    """here we're constructing a closure for our streamreader callback.  this
    is used in the case that we pass a callback into _out or _err, meaning we
    want to our callback to handle each bit of output

    we construct the closure based on how many arguments it takes.  the reason
    for this is to make it as easy as possible for people to use, without
    limiting them.  a new user will assume the callback takes 1 argument (the
    data).  as they get more advanced, they may want to terminate the process,
    or pass some stdin back, and will realize that they can pass a callback of
    more args"""
    ...

def get_exc_exit_code_would_raise(exit_code, ok_codes, sigpipe_ok): ...
def handle_process_exit_code(exit_code):
    """ this should only ever be called once for each child process """
    ...

def no_interrupt(syscall, *args, **kwargs):
    """ a helper for making system calls immune to EINTR """
    ...

class OProc(object):
    """this class is instantiated by RunningCommand for a command to be exec'd.
    it handles all the nasty business involved with correctly setting up the
    input/output to the child process.  it gets its name for subprocess.Popen
    (process open) but we're calling ours OProc (open process)"""

    _default_window_size = ...
    STDOUT = ...
    STDERR = ...
    def __init__(self, command, parent_log, cmd, stdin, stdout, stderr, call_args, pipe, process_assign_lock) -> None:
        """
        cmd is the full list of arguments that will be exec'd.  it includes the program name and all its arguments.

        stdin, stdout, stderr are what the child will use for standard input/output/err.

        call_args is a mapping of all the special keyword arguments to apply to the child process.
        """
        ...
    def __repr__(self): ...
    @property
    def output_thread_exc(self): ...
    @property
    def input_thread_exc(self): ...
    @property
    def bg_thread_exc(self): ...
    def change_in_bufsize(self, buf): ...
    def change_out_bufsize(self, buf): ...
    def change_err_bufsize(self, buf): ...
    @property
    def stdout(self): ...
    @property
    def stderr(self): ...
    def get_pgid(self):
        """return the CURRENT group id of the process. this differs from
        self.pgid in that this reflects the current state of the process, where
        self.pgid is the group id at launch"""
        ...
    def get_sid(self):
        """return the CURRENT session id of the process. this differs from
        self.sid in that this reflects the current state of the process, where
        self.sid is the session id at launch"""
        ...
    def signal_group(self, sig): ...
    def signal(self, sig): ...
    def kill_group(self): ...
    def kill(self): ...
    def terminate(self): ...
    def is_alive(self):
        """polls if our child process has completed, without blocking.  this
        method has side-effects, such as setting our exit_code, if we happen to
        see our child exit while this is running"""
        ...
    def wait(self):
        """ waits for the process to complete, handles the exit code """
        ...

def input_thread(log, stdin, is_alive, quit, close_before_term):
    """this is run in a separate thread.  it writes into our process's
    stdin (a streamwriter) and waits the process to end AND everything that
    can be written to be written"""
    ...

def event_wait(ev, timeout=...): ...
def background_thread(timeout_fn, timeout_event, handle_exit_code, is_alive, quit):
    """ handles the timeout logic """
    ...

def output_thread(log, stdout, stderr, timeout_event, is_alive, quit, stop_output_event):
    """this function is run in a separate thread.  it reads from the
    process's stdout stream (a streamreader), and waits for it to claim that
    its done"""
    ...

class DoneReadingForever(Exception): ...
class NotYetReadyToRead(Exception): ...

def determine_how_to_read_input(input_obj):
    """given some kind of input object, return a function that knows how to
    read chunks of that input object.

    each reader function should return a chunk and raise a DoneReadingForever
    exception, or return None, when there's no more data to read

    NOTE: the function returned does not need to care much about the requested
    buffering type (eg, unbuffered vs newline-buffered).  the StreamBufferer
    will take care of that.  these functions just need to return a
    reasonably-sized chunk of data."""
    ...

def get_queue_chunk_reader(stdin): ...
def get_callable_chunk_reader(stdin): ...
def get_iter_string_reader(stdin):
    """return an iterator that returns a chunk of a string every time it is
    called.  notice that even though bufsize_type might be line buffered, we're
    not doing any line buffering here.  that's because our StreamBufferer
    handles all buffering.  we just need to return a reasonable-sized chunk."""
    ...

def get_iter_chunk_reader(stdin): ...
def get_file_chunk_reader(stdin): ...
def bufsize_type_to_bufsize(bf_type):
    """for a given bufsize type, return the actual bufsize we will read.
    notice that although 1 means "newline-buffered", we're reading a chunk size
    of 1024.  this is because we have to read something.  we let a
    StreamBufferer instance handle splitting our chunk on newlines"""
    ...

class StreamWriter(object):
    """StreamWriter reads from some input (the stdin param) and writes to a fd
    (the stream param).  the stdin may be a Queue, a callable, something with
    the "read" method, a string, or an iterable"""

    def __init__(self, log, stream, stdin, bufsize_type, encoding, tty_in) -> None: ...
    def fileno(self):
        """defining this allows us to do poll on an instance of this
        class"""
        ...
    def write(self):
        """attempt to get a chunk of data to write to our child process's
        stdin, then write it.  the return value answers the questions "are we
        done writing forever?" """
        ...
    def close(self): ...

def determine_how_to_feed_output(handler, encoding, decode_errors): ...
def get_fd_chunk_consumer(handler): ...
def get_file_chunk_consumer(handler): ...
def get_callback_chunk_consumer(handler, encoding, decode_errors): ...
def get_cstringio_chunk_consumer(handler): ...
def get_stringio_chunk_consumer(handler, encoding, decode_errors): ...

class StreamReader(object):
    """reads from some output (the stream) and sends what it just read to the
    handler."""

    def __init__(
        self, log, stream, handler, buffer, bufsize_type, encoding, decode_errors, pipe_queue=..., save_data=...
    ) -> None: ...
    def fileno(self):
        """defining this allows us to do poll on an instance of this
        class"""
        ...
    def close(self): ...
    def write_chunk(self, chunk): ...
    def read(self): ...

class StreamBufferer(object):
    """this is used for feeding in chunks of stdout/stderr, and breaking it up
    into chunks that will actually be put into the internal buffers.  for
    example, if you have two processes, one being piped to the other, and you
    want that, first process to feed lines of data (instead of the chunks
    however they come in), OProc will use an instance of this class to chop up
    the data and feed it as lines to be sent down the pipe"""

    def __init__(self, buffer_type, encoding=..., decode_errors=...) -> None: ...
    def change_buffering(self, new_type): ...
    def process(self, chunk): ...
    def flush(self): ...

def with_lock(lock): ...
@with_lock(PUSHD_LOCK)
def pushd(path):
    """pushd changes the actual working directory for the duration of the
    context, unlike the _cwd arg this will work with other built-ins such as
    sh.glob correctly"""
    ...

@contextmanager
def args(**kwargs):
    """allows us to temporarily override all the special keyword parameters in
    a with context"""
    ...

class Environment(dict):
    """this allows lookups to names that aren't found in the global scope to be
    searched for as a program name.  for example, if "ls" isn't found in this
    module's scope, we consider it a system program and try to find it.

    we use a dict instead of just a regular object as the base class because the
    exec() statement used in the run_repl requires the "globals" argument to be a
    dictionary"""

    whitelist = ...
    def __init__(self, globs, baked_args=...) -> None:
        """baked_args are defaults for the 'sh' execution context.  for
        example:

            tmp = sh(_out=StringIO())

        'out' would end up in here as an entry in the baked_args dict"""
        ...
    def __getitem__(self, k): ...
    def b_cd(self, path=...): ...
    def b_which(self, program, paths=...): ...

class Contrib(ModuleType):
    @classmethod
    def __call__(cls, name): ...

mod_name = __name__ + ".contrib"
contrib = Contrib(mod_name)
@contrib("git")
def git(orig):
    """ most git commands play nicer without a TTY """
    ...

@contrib("sudo")
def sudo(orig):
    """a nicer version of sudo that uses getpass to ask for a password, or
    allows the first argument to be a string password"""
    ...

@contrib("ssh")
def ssh(orig):
    """ An ssh command for automatic password login """
    class SessionContent(object): ...
    class SSHInteract(object): ...

def run_repl(env): ...

class SelfWrapper(ModuleType):
    def __init__(self, self_module, baked_args=...) -> None: ...
    def __getattr__(self, name): ...
    def __call__(self, **kwargs):
        """returns a new SelfWrapper object, where all commands spawned from it
        have the baked_args kwargs set on them by default"""
        ...

def in_importlib(frame):
    """ helper for checking if a filename is in importlib guts """
    ...

def register_importer():
    """registers our fancy importer that can let us import from a module name,
    like:

        import sh
        tmp = sh()
        from tmp import ls
    """
    ...

def fetch_module_from_frame(name, frame): ...

class ModuleImporterFromVariables(object):
    """a fancy importer that allows us to import from a variable that was
    recently set in either the local or global scope, like this:

        sh2 = sh(_timeout=3)
        from sh2 import ls

    """

    def __init__(self, restrict_to=...) -> None: ...
    def find_module(self, mod_fullname, path=...):
        """mod_fullname doubles as the name of the VARIABLE holding our new sh
        context.  for example:

            derp = sh()
            from derp import ls

        here, mod_fullname will be "derp".  keep that in mind as we go through
        the rest of this function"""
        ...
    def load_module(self, mod_fullname): ...

def run_tests(env, locale, args, version, force_select, **extra_env): ...

if __name__ == "__main__":
    def parse_args(): ...
    action = None
else:
    self = sys.modules[__name__]
